1,362c1,419
< import System.Environment
< import Data.List
< import Data.Char
< 
< -- An assignment list, or macro
< 
< data Val = Ival Int | Sval String
< 
< type Assignment =  ([Int], Int )
< type Symboltable = [(String,Int)]
< type Paramtable = [(String,Int)]
< type Parmtable=[(String,Int)]
< type Macro = (String,[([Int],Val)])
< 
< globals::Symboltable
< globals = []
< 
< --
< -- microcode fields, must be lower case?
< --
< 
< -- 
< -- microcode fields, must be lower case?
< -- 
< 
< -- A word is 
< -- ORG or
< -- Labels and number followed by macros any number followed by ;
< --   macro is  macro_string followed by optional paramlist
< --   paramlist is ( followed by expressions any number followed by )
< --   params are set to $1, $2 .. $n and substituted into 
< --    field definitions for the macro
< 
< bitwidth = 96
< 
< ben0=[0..2]
< afd=[3]
< ret=[4]
< fdn=[5]
< fdv=[6]
< frcfirst=[7]
< ben1=[8..10]
< nad=[11..20]
< maluzero=[21]
< malu=[21..23]
< quo_bits=[21..23]
< enable_div_misc=[24]
< override_ralu_field=[25]
< residual=[26..27]
< flow_xtos=[28]
< exr_field=[29]
< eyr_field=[30]
< shift=[31..32]
< mark_bit=[33]
< input_lat_field=[34]
< mul_cnt_msb=[34]
< enable_excp=[35]
< msc_a=[36..39]
< msc_b=[40..43]
< emit=[44..59]
< msc_c=[44..47]
< msc_d=[48..51]
< wire_or=[48..51]
< div_clk=[44..47]
< rfx_wr_addr=[44..47]
< emit_right_half=[52..59]
< emit_right_three=[48..59]
< shift_l_r=[52]
< shift_ge_64=[53]
< shift_dist=[54..59]
< rfx_rd_addr=[52..59]
< interrupt_mask=[52..59]
< latx=[60]
< laty=[61]
< exmx=[60..61]
< exl_field=[62]
< eyl_field=[63]
< eymx=[62..63]
< flow_sel=[64..65]
< sign=[64..65]
< rf_rd_sel=[66..67]
< ealu=[66..67]
< zero_eymx=[68]
< spare3=[69]
< parity=[70]
< rf_wr_sel=[71]
< flipr=[72]
< flipw=[73]
< 
< -- fields can have default values
< defaults::[([Int],Val)]
< defaults=[(afd,Ival 1),(ben1,Ival 4),(enable_div_misc,Ival 1),(override_ralu_field,Ival 1),
<   (flow_xtos,Ival 1), (exr_field,Ival 1),(shift,Ival 2),(mark_bit,Ival 1),(input_lat_field,Ival 1),
<   (mul_cnt_msb,Ival 1),(enable_excp,Ival 1),(msc_a,Ival 8),(msc_b,Ival 8),
<   (eymx,Ival 3),(latx,Ival 1),(laty,Ival 1),
<   (zero_eymx,Ival 1),(exl_field,Ival 1),(eyl_field,Ival 1)]
< 
< constants::Symboltable
< constants=[("SGL",0),("DBL",1),("EXT",3),("NEAREST",0),
<            ("ZERO",1),("PLUS INF",2),("MINUS INF",3),
<            ("INTEGER.OVFL",0),("INTEGER.DIV0",4),("FLOATING.INVL",5),
<            ("FLOATING.INEX",6)]
< 
< 
< macrodefs:: [Macro]
< --
< --
< -- macrodefs are just list of [(macrostring,[(field,val)] )
< --   macroname is what macro will be invoke with
< --  [(field, val)] = list of fields = set of ints, val = int or string
< --       if val is int, field will get val of int
< --       if val is string, field will get lookup val parmTable
< --       where parmTable is made up of the parms that are at the end
< --       of the macro invocation in parens  e.g.  NAD(CA+3), puts CA+3 in the
< --          table as [("$0", CA+3)]
< 
< macrodefs = [ ("BEN 9 NOT INT DIV 0 TRAP",[ ( ben0, Ival 0), (ben1,Ival 2)] ),
<  ("BEN 9 CNTR EQ 0",[( ben0, Ival 0), (ben1, Ival 0 )] ),
<  ("BEN 9 32 X 32", [ ( ben0, Ival 0), (ben1, Ival 3)] ),
<  ("BEN 9 NOP", [ ( ben0, Ival 0), (ben1, Ival 4)] ),
<  ("BEN 9 NOT EXR 15", [ ( ben0,Ival 0), (ben1,Ival 5)] ),
<  ("BEN 9 NOT FRACY 00", [ ( ben0,Ival 0), (ben1,Ival 6)] ),
<  ("BEN 9 NOT FLAG 1", [ ( ben0, Ival 0), (ben1,Ival 7)] ),
<  ("BEN 9 NOT OV TRAP", [ ( ben0, Ival 1), (ben1, Ival 0)] ),
<  ("BEN 9 NOT UN TRAP", [ ( ben0, Ival 1), (ben1,Ival 1)] ),
<  ("BEN 9 NOT DZ TRAP", [ ( ben0, Ival 1), (ben1,Ival 2)] ),
<  ("BEN 9 NOT IV TRAP", [ ( ben0, Ival 1), (ben1,Ival 3)] ),
<  ("BEN 9 NOT IX TRAP", [ ( ben0, Ival 1), (ben1, Ival 4)] ),
<  ("BEN 9 NOT UNORDERED REL", [ ( ben0, Ival 1), (ben1, Ival 5)] ),
<  ("BEN 9 MAG SUB", [ ( ben0, Ival 1), (ben1,Ival 6)] ),
<  ("BEN 9 NOT IX TRAP COND AND IX TRAP", [ ( ben0, Ival 1), (ben1,Ival 7)] ),
<  ("BEN 9 NOT LIVE IX COND", [ ( ben0, Ival 2), (ben1, Ival 0)] ),
<  ("BEN 9 NOT PREC MSB", [ ( ben0, Ival 2), (ben1,Ival 1)] ),
<  ("BEN 9 NOT FLUSH TO ZERO", [ ( ben0, Ival  2), (ben1,Ival 2)] ),
<  ("BEN 9 NOT SIGN YR", [ ( ben0, Ival 2), (ben1, Ival 3)] ),
<  ("BEN 9 NOT FRACX F BIT", [ ( ben0, Ival 2), (ben1,Ival 4)] ),
<  ("BEN 9 NOT PACK I BIT", [ ( ben0,Ival 2), (ben1,Ival 5)] ),
<  ("BEN 9 MALU EQ 0", [ ( ben0, Ival 2), (ben1,Ival 6)] ),
<  ("BEN 9 NOT XNO", [ ( ben0, Ival 2), (ben1, Ival 7)] ),
<  ("BEN 9 NOT EX0 18", [ ( ben0, Ival 3), (ben1,Ival 0)] ),
<  ("BEN 9 NOT EX0 19", [ ( ben0, Ival 3), (ben1,Ival 1)] ),
<  ("BEN 9 NOT POST NORM", [ ( ben0, Ival 3), (ben1,Ival 2)] ),
<  ("BEN 9 FRAC OVFL", [ ( ben0, Ival  3), (ben1, Ival 3)] ),
<  ("BEN 9 NOT MUL OR DIV 99", [ ( ben0, Ival  3), (ben1, Ival 4)] ),
<  ("BEN 9 MALU 99-63 EQ 0", [ ( ben0, Ival  3), (ben1, Ival 5)] ),
<  ("BEN 9 NOT SIGN EYL", [ ( ben0, Ival  3), (ben1, Ival 6)] ),
<  ("BEN 9 MEM OP", [ ( ben0, Ival  3), (ben1, Ival 7)] ),
<  ("BEN 8 EALU 00", [ ( ben0, Ival  4), (ben1, Ival 0)] ),
<  ("BEN 9 EALU EQ 0", [ ( ben0, Ival  4), (ben1, Ival 0)] ),
<  ("BEN 8 FLAG 1", [ ( ben0, Ival  4), (ben1, Ival 1)] ),
<  ("BEN 9 NOT FLAG 2", [ ( ben0, Ival  4), (ben1, Ival 1)] ),
<  ("BEN 8 RMODE MSB", [ ( ben0, Ival  4), (ben1, Ival 2)] ),
<  ("BEN 9 NOT RMODE LSB", [ ( ben0, Ival  4), (ben1, Ival 2)] ),
<  ("BEN 8 PREC MSB", [ ( ben0, Ival  4), (ben1, Ival 3)] ),
<  ("BEN 9 NOT EXP OVLF", [ ( ben0, Ival  4), (ben1, Ival 3)] ),
<  ("BEN 8 EXP UNFL", [ ( ben0, Ival  4), (ben1, Ival 4)] ),
<  ("BEN 9 NOT EXP OVFL", [ ( ben0, Ival  4), (ben1, Ival 4)] ),
<  ("BEN 8 SPARE 3", [ ( ben0, Ival  4), (ben1, Ival 5)] ),
<  ("BEN 9 NOT INT OVFL", [ ( ben0, Ival  4), (ben1, Ival 5)] ),
<  ("BEN 8 EX1 OR EY1 26", [ ( ben0, Ival  4), (ben1, Ival 6)] ),
<  ("BEN 9 NOT EX0 OR EY0", [ ( ben0, Ival  4), (ben1, Ival 6)] ),
<  ("BEN 8 XN0", [ ( ben0, Ival  4), (ben1, Ival 7)] ),
<  ("BEN 9 NOT YN0", [ ( ben0, Ival  4), (ben1, Ival 7)] ),
<  ("BEN 8 XINF", [ ( ben0, Ival  5), (ben1, Ival 0)] ),
<  ("BEN 9 NOT YINF", [ ( ben0, Ival  5), (ben1, Ival 0)] ),
<  ("BEN 8 XNAN", [ ( ben0, Ival  5), (ben1, Ival 1)] ),
<  ("BEN 9 NOT YNAN", [ ( ben0, Ival  5), (ben1, Ival 1)] ),
<  ("BEN 8 EX1 OR EY1 2A", [ ( ben0, Ival  5), (ben1, Ival 2)] ),
<  ("BEN 9 NOT EX0 AND EY0", [ ( ben0, Ival  5), (ben1, Ival 2)] ),
<  ("BEN 8 EXT PREC", [ ( ben0, Ival  5), (ben1, Ival 3)] ),
<  ("BEN 9 ALU DATA NOT VALID", [ ( ben0, Ival  5), (ben1, Ival 3)] ),
<  ("BEN 8 NOT FADD TYPE", [ ( ben0, Ival  5), (ben1, Ival 4)] ),
<  ("BEN 9 NOT MUL", [ ( ben0, Ival  5), (ben1, Ival 4)] ),
<  ("BEN 8 EXR 00", [ ( ben0, Ival  5), (ben1, Ival 5)] ),
<  ("BEN 9 SPARE 4", [ ( ben0, Ival  5), (ben1, Ival 5)] ),
<  ("BEN 8 SPARE 5", [ ( ben0, Ival  5), (ben1, Ival 6)] ),
<  ("BEN 9 NOT DEC CARRY OUT", [ ( ben0, Ival  5), (ben1, Ival 6)] ),
<  ("BEN 8 SPARE 6", [ ( ben0, Ival  5), (ben1, Ival 7)] ),
<  ("BEN 9 NOT ROUNDED", [ ( ben0, Ival  5), (ben1, Ival 7)] ),
<  ("BEN 7 ALUOP 2", [ ( ben0, Ival  7), (ben1, Ival 0)] ),
<  ("BEN 8 ALUOP 3", [ ( ben0, Ival  7), (ben1, Ival 0)] ),
<  ("BEN 9 NOT ALUOP 4", [ ( ben0, Ival  7), (ben1, Ival 0)] ),
<  ("BEN 7 XN0", [ ( ben0, Ival  7), (ben1, Ival 1)] ),
<  ("BEN 8 EY0 39", [ ( ben0, Ival  7), (ben1, Ival 1)] ),
<  ("BEN 9 NOT FY0 39", [ ( ben0, Ival  7), (ben1, Ival 1)] ),
<  ("BEN 7 EX1", [ ( ben0, Ival  7), (ben1, Ival 2)] ),
<  ("BEN 8 EX0", [ ( ben0, Ival  7), (ben1, Ival 2)] ),
<  ("BEN 9 NOT FX0", [ ( ben0, Ival  7), (ben1, Ival 2)] ),
<  ("BEN 7 EY1", [ ( ben0, Ival  7), (ben1, Ival 3)] ),
<  ("BEN 8 EY0 3C", [ ( ben0, Ival  7), (ben1, Ival 3)] ),
<  ("BEN 9 NOT FY0 3C", [ ( ben0, Ival  7), (ben1, Ival 3)] ),
<  ("SIGN ADD", [ ( sign, Ival  0) ]),
<  ("SIGN MUL OR DIV", [ ( sign, Ival  1) ]),
<  ("SIGN X OP", [ ( sign, Ival  2) ]),
<  ("SIGN Y OP", [ ( sign, Ival  3) ]),
<  ("SIGN ZERO", [ ( sign, Ival  4) ]),
<  ("SIGN ONE", [ ( sign, Ival  5) ]),
<  ("SIGN XR", [ ( sign, Ival  6) ]),
<  ("SIGN RMODE", [ ( sign, Ival  7) ]),
<  ("EXMX EYL", [ ( exmx, Ival  0) ]),
<  ("EXMX ADD", [ ( exmx, Ival  0) ]),
<  ("EXMX EXL", [ ( exmx, Ival  1) ]),
<  ("EXMX ZERO", [ ( exmx, Ival  2) ]),
<  ("EXMX EXR", [ (exmx, Ival  3) ]),
<  ("EYMX EYR", [ ( eymx, Ival  0) ]),
<  ("EYMX PRIO ENCODE", [ ( eymx, Ival  1) ]),
<  ("EYMX EMIT", [ ( eymx, Ival  2),(emit, Sval "$0") ]), 
<  ("EYMX EMIT SHORT", [ ( eymx, Ival 2),(emit_right_three,Sval "$0") ]),
<  ("EYMX EYL", [ (exmx, Ival 3) ]),
<  ("EYMX ZERO", [(zero_eymx, Ival 0 )]),
<  ("EALU HALF X", [(ealu,Ival 0)]),
<  ("EALU X+Y", [(ealu,Ival 1)]),
<  ("EALU PASS X", [(ealu,Ival 1),(zero_eymx, Ival 0)]),
<  ("EALU PASS Y", [(ealu,Ival 1),(exmx,Ival 2)]),
<  ("EALU X-Y", [(ealu,Ival 2)]),
<  ("EALU HW", [(ealu,Ival 3),(zero_eymx, Ival 0)]),
<  ("EALU HW NOT EYMX ZERO", [(ealu,Ival 3)]),
<  ("EALU ZERO", [(ealu, Ival 0),(exmx,Ival 2)]),
<  ("RF RD SEL FD RAM", [(rf_rd_sel, Ival 0)]),
<  ("RF RD SEL HW", [(rf_rd_sel,Ival 1)]),
<  ("RF RD SEL EMIT", [(rf_rd_sel,Ival 2),(flipr,Ival 1)]),
<  ("RFX RD", [(rf_rd_sel,Ival 2),(flipr,Ival 1),(rfx_rd_addr,Sval "$0")]),
<  ("RF RD SEL CNTR", [(rf_rd_sel,Ival 3)]),
<  ("RF WR SEL EMIT", [(rf_wr_sel, Ival 0),(flipw,Ival 13)]),
<  ("RFX WR", [(rf_wr_sel, Ival 0),(rfx_wr_addr,Sval "$0"),(flipw,Ival 1)]),
<  ("RFX WR SEL CNTR", [(rf_wr_sel,Ival 1)]),
<  ("FLOW SEL XY", [(flow_sel, Ival 0)]),
<  ("FLOW SEL XC", [(flow_sel,Ival 1)]),
<  ("FLOW SEL CY", [(flow_sel,Ival 2)]),
<  ("FLOW SEL CX", [(flow_sel,Ival 3)]),
<  ("LD MUL CNTR 0", [(msc_a,Ival 1),(mul_cnt_msb, Ival 0),(residual, Ival 0),(override_ralu_field, Ival 0)]),
<  ("LD MUL CNTR 1", [(msc_a,Ival 1),(mul_cnt_msb, Ival 0),(residual,Ival 1),(override_ralu_field, Ival 0)]),
<  ("LD MUL CNTR 2", [(msc_a,Ival 1),(mul_cnt_msb, Ival 0),(residual,Ival 2),(override_ralu_field, Ival 0)]),
<  ("LD MUL CNTR 3", [(msc_a,Ival 1),(mul_cnt_msb, Ival 0),(residual,Ival 3),(override_ralu_field, Ival 0)]),
<  ("RESET MUL", [(msc_a,Ival 1)]),
<  ("SET FRC FLAG LO LAT A", [(msc_a,Ival 2)]),
<  ("MSC A SPARE 1", [(msc_a,Ival 3)]),
<  ("ENABLE RF WR", [(msc_a,Ival 4)]),
<  ("CALL", [(msc_a,Ival 6)]),
<  ("READ", [(msc_a,Ival 11)]),
<  ("ALLOW HW SET IX", [(msc_a,Ival 12)]),
<  ("PACK EXT FRAC", [(msc_a,Ival 13)]),
<  ("HW RMXS", [(msc_b, Ival 0)]),
<  ("SET SQR LAT", [(msc_b,Ival 1)]),
<  ("SET FRC FLAG LO LAT B", [(msc_b,Ival 2)]),
<  ("SET FRC FLAG LO LAT", [(msc_b,Ival 2)]),
<  ("FRC FLAG HI", [(msc_b,Ival 3)]),
<  ("FRC V BIT HI", [(msc_b,Ival 4)]),
<  ("FRC FIRST DECODE", [(frcfirst,Ival 1)]),
<  ("LD BOTH PREC REG 0", [(msc_b,Ival 6),(residual,Sval "$0"),(rf_wr_sel, Ival 0)]),
<  ("LD BOTH PREC REG 1", [(msc_b,Ival 6),(residual,Sval "$0"),(rf_wr_sel,Ival 1)]),
<  ("LD BOTH PREC REG 2", [(msc_b,Ival 7),(residual,Sval "$0"),(rf_wr_sel, Ival 0)]),
<  ("LD BOTH PREC REG 3", [(msc_b,Ival 7),(residual,Sval "$0"),(rf_wr_sel,Ival 1)]),
<  ("FRC IR 02", [(msc_b,Ival 11)]),
<  ("LD SEQ CNTR", [(msc_b,Ival 12),(emit_right_half,Sval "$0"),(eymx,Ival 2),(ealu,Ival 1),(exmx,Ival 2)]),
<  ("LD SEQ CNTR NOT EMIT", [(msc_b,Ival 12)]),
<  ("LD RF CNTRS", [(msc_b,Ival 13)]),
<  ("INC RD CNTRS", [(msc_b,Ival 14)]),
<  ("LD AND INCR RF CNTRS", [(msc_b,Ival 15)]),
<  ("SET OV", [(msc_a,Ival 10),(msc_c, Ival 0)]),
<  ("SET UN", [(msc_a,Ival 10),(msc_c,Ival 1)]),
<  ("SET IV", [(msc_a,Ival 10),(msc_c,Ival 2)]),
<  ("SET DZ", [(msc_a,Ival 10),(msc_c,Ival 3)]),
<  ("SET IX", [(msc_a,Ival 10),(msc_c,Ival 4)]),
<  ("CLK DENORM STICK BIT", [(msc_a,Ival 10),(msc_c,Ival 5)]),
<  ("SET INTEGER OV", [(msc_a,Ival 10),(msc_c,Ival 6)]),
<  ("SET INTEGER DZ", [(msc_a,Ival 10),(msc_c,Ival 7)]),
<  ("SET FSUB LAT", [(flow_xtos, Ival 0)]),
<  ("SET FSUBR LAT", [(enable_div_misc, Ival 0)]),
<  ("WR STATUS", [(msc_a,Ival 10),(msc_c,Ival 10)]),
<  ("SET SIGN MSB LAT", [(msc_a,Ival 10),(msc_c,Ival 11)]),
<  ("LD INTERRUPT MASK", [(msc_a,Ival 10),(msc_c,Ival 12),(interrupt_mask,Sval "$0")]),
<  ("ASCII LAT", [(msc_a,Ival 10),(msc_c,Ival 13),(maluzero,Ival 1)]),
<  ("ASCII ASIGN C BIT", [(msc_a,Ival 10),(msc_c,Ival 14)]),
<  ("CLR DENORM STICKY BIT", [(msc_a,Ival 10),(msc_c,Ival 15)]),
<  ("RD STATUS", [(msc_b,Ival 9),(msc_d, Ival 0)]),
<  ("MICRO RESET", [(msc_b,Ival 9),(msc_d,Ival 1)]),
<  ("MSC D SPARE 0", [(msc_b,Ival 9),(msc_d,Ival 2)]),
<  ("TRAP ALU", [(msc_b,Ival 9),(msc_d,Ival 2)]),
<  ("ZERO RALU CNTRLS", [(msc_b,Ival 9),(msc_d,Ival 3)]),
<  ("FRC PACK 00 HI", [(msc_b,Ival 9),(msc_d,Ival 4)]),
<  ("FRC HIDDEN BITS", [(msc_b,Ival 9),(msc_d,Ival 5)]),
<  ("SET MUL LAT", [(msc_b,Ival 9),(msc_d,Ival 6)]),
<  ("FRC QUO BITS", [(msc_b,Ival 9),(msc_d,Ival 7),(quo_bits,Sval"$0")]),
<  ("CLA INIT REM", [(msc_b,Ival 9),(msc_d,Ival 7)]),
<  ("LD RMODE REG", [(msc_b,Ival 9),(msc_d,Ival 9),(residual,Sval "$0")]),
<  ("LD MICROFLAGS", [(msc_b,Ival 9),(msc_d,Ival 10),(residual,Sval "$0")]),
<  ("LD RALU CNTL ZERO", [(msc_b,Ival 9),(msc_d,Ival 11),(residual, Ival 0)]),
<  ("LD RALU CNTL HALF X", [(msc_b,Ival 9),(msc_d,Ival 11),(residual,Ival 1)]),
<  ("LD RALU CNTL X", [(msc_b,Ival 9),(msc_d,Ival 11),(residual,Ival 2)]),
<  ("LD RALU CNTL MINUS X", [(msc_b,Ival 9),(msc_d,Ival 11),(residual,Ival 3)]),
<  ("ASCII CLR C BIT", [(msc_b,Ival 9),(msc_d,Ival 12)]),
<  ("RESET MUL LAT", [(msc_b,Ival 9),(msc_d,Ival 14)]),
<  ("SET XI ZERO LAT", [(msc_b,Ival 9),(msc_d,Ival 15)]),
<  ("DIV CLK QB", [(msc_a,Ival 9),(div_clk,Ival 14)]),
<  ("DIV CLK Q", [(msc_a,Ival 9),(div_clk,Ival 13)]),
<  ("DIV CLK RS", [(msc_a,Ival 9),(div_clk,Ival 11)]),
<  ("DIV CLK D", [(msc_a,Ival 9),(div_clk,Ival 7)]),
<  ("DIV CLK QB Q RS", [(msc_a,Ival 9),(div_clk,Ival 8)]),
<  ("DIV CLK QB RS", [(msc_a,Ival 9),(div_clk,Ival 10)]),
<  ("DIV CLK RS D", [(msc_a,Ival 9),(div_clk,Ival 3)]),
<  ("DIV CLK QB D", [(msc_a,Ival 9),(div_clk,Ival 6)]),
<  ("DIV CLK QB Q", [(msc_a,Ival 9),(div_clk,Ival 12)]),
<  ("DIV CLK Q QB", [(msc_a,Ival 9),(div_clk,Ival 12)]),
<  ("DIV CLK Q RS", [(msc_a,Ival 9),(div_clk,Ival 9)]),
<  ("DIV LD R CLR S MZ", [(enable_div_misc, Ival 0),(residual,Ival 2),(malu, Ival 0)]),
<  ("DIV LD D CLR Q", [(enable_div_misc, Ival 0),(residual,Ival 3),(maluzero,Ival 1)]),
<  ("DIV LD R CLR S", [(enable_div_misc, Ival 0),(residual,Ival 2),(maluzero,Ival 1)]),
<  ("DIV LD S CLR R", [(enable_div_misc, Ival 0),(residual,Ival 1),(maluzero,Ival 1)]),
<  ("DIV Q OUT CLR D", [(enable_div_misc, Ival 0),(residual, Ival 0)]),
<  ("CLEAR Q", [(enable_div_misc, Ival 0),(residual,Ival 3)]),
<  ("CLEAR S", [(enable_div_misc, Ival 0),(residual,Ival 2)]),
<  ("CLEAR R", [(enable_div_misc, Ival 0),(residual,Ival 1)]),
<  ("CLEAR D", [(enable_div_misc, Ival 0),(residual, Ival 0)]),
<  ("MALU ZERO", [(malu, Ival 0),(shift_l_r, Ival 0),(shift_ge_64,Ival 1)]),
<  ("ASCII TO INTEGER", [(malu,Ival 1)]),
<  ("ASCII X+Y", [(malu,Ival 2)]),
<  ("ASCII X-Y", [(malu,Ival 3)]),
<  ("MALU PASS Y", [(malu,Ival 5)]),
<  ("MALU Y-X", [(malu,Ival 6)]),
<  ("MALU Y+X", [(malu,Ival 7)]),
<  ("ALLOW FIRST DECODE", [(afd, Ival 0)]),
<  ("RETURN", [(ret,Ival 1)]),
<  ("FPA DONE NEXT", [(fdn,Ival 1)]),
<  ("FPA DATA VALID", [(fdv,Ival 1)]),
<  ("LAT X", [(latx, Ival 0),(msc_a,Ival 11)]),
<  ("LAT Y", [(laty, Ival 0),(msc_a,Ival 11)]),
<  ("EXL", [(exl_field, Ival 0),(msc_a,Ival 11)]),
<  ("EYL", [(eyl_field, Ival 0),(msc_a,Ival 11)]),
<  ("EXR", [(exr_field, Ival 0)]),
<  ("EYR", [(eyr_field, Ival 0)]),
<  ("SHIFT R EXP DIFF", [(shift, Ival 0)]),
<  ("SHIFT L EALU", [(shift,Ival 1),(override_ralu_field, Ival 0)]),
<  ("SHIFT R EALU", [(shift,Ival 1),(override_ralu_field,Ival 1)]),
<  ("SHIFT L EMIT", [(shift,Ival 2),(shift_l_r, Ival 0),(shift_dist,Sval "$0")]),
<  ("SHIFT R EMIT", [(shift,Ival 2),(shift_l_r,Ival 1),(shift_dist,Sval "$0")]),
<  ("SHIFT PASS", [(shift,Ival 2),(shift_l_r, Ival 0),(shift_dist, Ival 0)]),
<  ("SHIFT L PRIO ENCODE", [(shift,Ival 3)]),
<  ("SHIFT ZERO", [(shift_l_r, Ival 0),(shift_ge_64,Ival 1)]),
<  ("IA DE", [(wire_or,Ival 1),(msc_b,Ival 10)]),
<  ("PROD OE", [(wire_or,Ival 2),(msc_b,Ival 10)]),
<  ("MUL OE", [(wire_or,Ival 4),(msc_b,Ival 10)]),
<  ("DIV OE", [(wire_or,Ival 8),(msc_b,Ival 10)]),
<  ("WIRE OR ZERO", [(wire_or, Ival 0),(msc_b,Ival 10)]),
<  ("INPUT LAT", [(input_lat_field, Ival 0)]),
<  ("FLOW X TO S", [(flow_xtos,Ival 1)]),
<  ("FLOW X TO T", [(flow_xtos, Ival 0)]),
<  ("FLOW Y TO S", [(flow_xtos, Ival 0)]),
<  ("FLOW Y TO T", [(flow_xtos,Ival 1)]),
<  ("ENABLE EXCEPTIONS", [(enable_excp, Ival 0)]),
<  ("OVERRIDE RALU", [(override_ralu_field, Ival 0)]),
<  ("RALU ZERO", [(override_ralu_field, Ival 0),(malu, Ival 0)]),
<  ("MARK", [(mark_bit, Ival 0)]),
<  ("HALT", [(mark_bit, Ival 0)]),
<  ("TWO WORDS TO ALU AFTER TRAP", [(fdn, Ival 0),(fdv,Ival 1)]),
<  ("EXCP MSG TO ALU AFTER TRAP", [(fdn,Ival 1),(fdv, Ival 0)]),
<  ("ONE WORD TO ALU AFTER TRAP", [(fdn,Ival 1),(fdv,Ival 1)]),
<  ("FREM NOP TERMINATION", [(fdn, Ival 0),(fdv,Ival 1)]),
<  ("FREM QUOTIENT DATA VALID", [(fdn,Ival 1),(fdv,Ival 1)]),
<  ("FREM REMAINDER DATA VALID", [(fdv,Ival 1)]),
<  ("EMIT RIGHT HALF", [(emit_right_half,Sval "$0")]),
<  ("NAD",[(nad,Sval "$0")]) ]
---
> import System.Environment
> import Debug.Trace
> import GHC.Integer
> import Data.List
> import Data.Char
> 
> -- An assignment list, or macro
> 
> data Val = Ival Integer | Sval String
> 
> type Assignment =  ([Int], Int )
> type Symboltable = [(String,Int)]
> type Paramtable = [(String,Integer)]
> type Parmtable=[(String,Integer)]
> type Macro = (String,[(String,[Int],Val)])
> type DisassembledField=(String,[Int],Integer)
> type DisassembledFieldList=[DisassembledField]
> type SplitOutLine=(String,String)
> type SplitOutLineInt=(Int,Int)   
> 
> globals::Symboltable
> globals = []
> 
> -- 
> -- microcode fields, must be lower case?
> -- 
> 
> -- A word is 
> -- ORG or
> -- Labels and number followed by macros any number followed by ;
> --   macro is  macro_string followed by optional paramlist
> --   paramlist is ( followed by expressions any number followed by )
> --   params are set to $1, $2 .. $n and substituted into 
> --    field definitions for the macro
> 
> bitwidth = 96
> 
> ben0=[0..2]
> afd=[3]
> ret=[4]
> fdn=[5]
> fdv=[6]
> frcfirst=[7]
> ben1=[8..10]
> nad=[11..20]
> maluzero=[21]
> malu=[21..23]
> quo_bits=[21..23]
> enable_div_misc=[24]
> override_ralu_field=[25]
> residual=[26..27]
> flow_xtos=[28]
> exr_field=[29]
> eyr_field=[30]
> shift=[31..32]
> mark_bit=[33]
> input_lat_field=[34]
> mul_cnt_msb=[34]
> enable_excp=[35]
> msc_a=[36..39]
> msc_b=[40..43]
> emit=[44..59]
> msc_c=[44..47]
> msc_d=[48..51]
> wire_or=[48..51]
> div_clk=[44..47]
> rfx_wr_addr=[44..47]
> emit_right_half=[52..59]
> emit_right_three=[48..59]
> shift_l_r=[52]
> shift_ge_64=[53]
> shift_dist=[54..59]
> rfx_rd_addr=[52..59]
> interrupt_mask=[52..59]
> latx=[60]
> laty=[61]
> exmx=[60..61]
> exl_field=[62]
> eyl_field=[63]
> eymx=[62..63]
> flow_sel=[64..65]
> sign=[64,65,74]
> rf_rd_sel=[66..67]
> ealu=[66..67]
> zero_eymx=[68]
> spare3=[69]
> parity=[70]
> rf_wr_sel=[71]
> flipr=[72]
> flipw=[73]
> 
> allfields = [("ben0",ben0),
>  ("afd",afd),
>  ("ret",ret),
>  ("fdn",fdn),
>  ("fdv",fdv),
>  ("frcfirst",frcfirst),
>   ("ben1",ben1),
>   ("nad",nad),
>   ("maluzero",maluzero),
>   ("malu",malu),
>   ("quo_bits",quo_bits),
>   ("enable_div_misc",enable_div_misc),
>   ("override_ralu_field",override_ralu_field),
>   ("residual",residual),
>   ("flow_xtos",flow_xtos),
>   ("exr_field",exr_field),
>   ("eyr_field",eyr_field),
>   ("shift",shift),
>   ("mark_bit",mark_bit),
>   ("input_lat_field",input_lat_field),
>   ("mul_cnt_msb",mul_cnt_msb),
>   ("enable_excp",enable_excp),
>   ("msc_a",msc_a),
>   ("msc_b",msc_b),
>   ("emit",emit),
>   ("msc_c",msc_c),
>   ("msc_d",msc_d),
>   ("wire_or",wire_or),
>   ("div_clk",div_clk),
>   ("rfx_wr_addr",rfx_wr_addr),
>   ("emit_right_half",emit_right_half),
>   ("emit_right_three",emit_right_three),
>   ("shift_l_r",shift_l_r),
>   ("shift_ge_64",shift_ge_64),
>   ("shift_dist",shift_dist),
>   ("rfx_rd_addr",rfx_rd_addr),
>   ("interrupt_mask",interrupt_mask),
>   ("latx",latx),
>   ("laty",laty),
>   ("exmx",exmx),
>   ("exl_field",exl_field),
>   ("eyl_field",eyl_field),
>   ("eymx",eymx),
>   ("flow_sel",flow_sel),
>   ("sign",sign),
>   ("rf_rd_sel",rf_rd_sel),
>   ("ealu",ealu),
>   ("zero_eymx",zero_eymx),
>   ("spare3",spare3),
>   ("parity",parity),
>   ("rf_wr_sel",rf_wr_sel),
>   ("flipr",flipr),
>   ("flipw",flipw)]
> 
> -- fields can have default values
> defaults::[([Int],Val)]
> defaults=[(afd,Ival 1),(ben1,Ival 6),(enable_div_misc,Ival 1),(override_ralu_field,Ival 1),
>   (flow_xtos,Ival 1), (exr_field,Ival 1),(shift,Ival 2),(mark_bit,Ival 1),(input_lat_field,Ival 1),
>   (mul_cnt_msb,Ival 1),(enable_excp,Ival 1),(msc_a,Ival 8),(msc_b,Ival 8),
>   (eymx,Ival 3),(latx,Ival 1),(laty,Ival 1),
>   (zero_eymx,Ival 1),(exl_field,Ival 1),(eyl_field,Ival 1)]
> 
> constants::Symboltable
> constants=[("SGL",0),("DBL",1),("EXT",3),("NEAREST",0),
>            ("ZERO",1),("PLUS INF",2),("MINUS INF",3),
>            ("INTEGER.OVFL",0),("INTEGER.DIV0",4),("FLOATING.INVL",5),
>            ("FLOATING.INEX",6)]
> 
> 
> macrodefs:: [Macro]
> --
> --
> -- macrodefs are just list of [(macrostring,[(fieldname,field,val)] )
> --   macroname is what macro will be invoke with
> --  [(fieldname,field, val)] = field name,
> --                    list of fields = set of ints, val = int or string
> --       if val is int, field will get val of int
> --       if val is string, field will get lookup val parmTable
> --       where parmTable is made up of the parms that are at the end
> --       of the macro invocation in parens  e.g.  NAD(CA+3), puts CA+3 in the
> --          table as [("$0", CA+3)]
> 
> macrodefs = [ ("BEN 9 NOT INT DIV 0 TRAP",[ ( "ben0",ben0, Ival 0), ("ben1",ben1,Ival 2)] ),
>  ("BEN 9 CNTR EQ 0",[( "ben0",ben0, Ival 0), ("ben1",ben1, Ival 0 )] ),
>  ("BEN 9 32 X 32", [ ( "ben0",ben0, Ival 0), ("ben1",ben1, Ival 3)] ),
>  ("BEN 9 NOP", [ ( "ben0",ben0, Ival 0), ("ben1",ben1, Ival 4)] ),
>  ("BEN 9 NOT EXR 15", [ ( "ben0",ben0,Ival 0), ("ben1",ben1,Ival 5)] ),
>  ("BEN 9 NOT FRACY 00", [ ( "ben0",ben0,Ival 0), ("ben1",ben1,Ival 6)] ),
>  ("BEN 9 NOT FLAG 1", [ ( "ben0",ben0, Ival 0), ("ben1",ben1,Ival 7)] ),
>  ("BEN 9 NOT OV TRAP", [ ( "ben0",ben0, Ival 1), ("ben1",ben1, Ival 0)] ),
>  ("BEN 9 NOT UN TRAP", [ ( "ben0",ben0, Ival 1), ("ben1",ben1,Ival 1)] ),
>  ("BEN 9 NOT DZ TRAP", [ ( "ben0",ben0, Ival 1), ("ben1",ben1,Ival 2)] ),
>  ("BEN 9 NOT IV TRAP", [ ( "ben0",ben0, Ival 1), ("ben1",ben1,Ival 3)] ),
>  ("BEN 9 NOT IX TRAP", [ ( "ben0",ben0, Ival 1), ("ben1",ben1, Ival 4)] ),
>  ("BEN 9 NOT UNORDERED REL", [ ( "ben0",ben0, Ival 1), ("ben1",ben1, Ival 5)] ),
>  ("BEN 9 MAG SUB", [ ( "ben0",ben0, Ival 1), ("ben1",ben1,Ival 6)] ),
>  ("BEN 9 NOT IX TRAP COND AND IX TRAP", [ ( "ben0",ben0, Ival 1), ("ben1",ben1,Ival 7)] ),
>  ("BEN 9 NOT LIVE IX COND", [ ( "ben0",ben0, Ival 2), ("ben1",ben1, Ival 0)] ),
>  ("BEN 9 NOT PREC MSB", [ ( "ben0",ben0, Ival 2), ("ben1",ben1,Ival 1)] ),
>  ("BEN 9 NOT FLUSH TO ZERO", [ ( "ben0",ben0, Ival  2), ("ben1",ben1,Ival 2)] ),
>  ("BEN 9 NOT SIGN YR", [ ( "ben0",ben0, Ival 2), ("ben1",ben1, Ival 3)] ),
>  ("BEN 9 NOT FRACX F BIT", [ ( "ben0",ben0, Ival 2), ("ben1",ben1,Ival 4)] ),
>  ("BEN 9 NOT PACK I BIT", [ ( "ben0",ben0,Ival 2), ("ben1",ben1,Ival 5)] ),
>  ("BEN 9 MALU EQ 0", [ ( "ben0",ben0, Ival 2), ("ben1",ben1,Ival 6)] ),
>  ("BEN 9 NOT XNO", [ ( "ben0",ben0, Ival 2), ("ben1",ben1, Ival 7)] ),
>  ("BEN 9 NOT EX0 18", [ ( "ben0",ben0, Ival 3), ("ben1",ben1,Ival 0)] ),
>  ("BEN 9 NOT EX0 19", [ ( "ben0",ben0, Ival 3), ("ben1",ben1,Ival 1)] ),
>  ("BEN 9 NOT POST NORM", [ ( "ben0",ben0, Ival 3), ("ben1",ben1,Ival 2)] ),
>  ("BEN 9 FRAC OVFL", [ ( "ben0",ben0, Ival  3), ("ben1",ben1, Ival 3)] ),
>  ("BEN 9 NOT MUL OR DIV 99", [ ( "ben0",ben0, Ival  3), ("ben1",ben1, Ival 4)] ),
>  ("BEN 9 MALU 99-63 EQ 0", [ ( "ben0",ben0, Ival  3), ("ben1",ben1, Ival 5)] ),
>  ("BEN 9 NOT SIGN EYL", [ ( "ben0",ben0, Ival  3), ("ben1",ben1, Ival 6)] ),
>  ("BEN 9 MEM OP", [ ( "ben0",ben0, Ival  3), ("ben1",ben1, Ival 7)] ),
>  ("BEN 8 EALU 00", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 0)] ),
>  ("BEN 9 EALU EQ 0", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 0)] ),
>  ("BEN 8 FLAG 1", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 1)] ),
>  ("BEN 9 NOT FLAG 2", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 1)] ),
>  ("BEN 8 RMODE MSB", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 2)] ),
>  ("BEN 9 NOT RMODE LSB", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 2)] ),
>  ("BEN 8 PREC MSB", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 3)] ),
>  ("BEN 9 NOT EXP OVLF", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 3)] ),
>  ("BEN 8 EXP UNFL", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 4)] ),
>  ("BEN 9 NOT EXP OVFL", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 4)] ),
>  ("BEN 8 SPARE 3", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 5)] ),
>  ("BEN 9 NOT INT OVFL", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 5)] ),
>  ("BEN 8 EX1 OR EY1 26", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 6)] ),
>  ("BEN 9 NOT EX0 OR EY0", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 6)] ),
>  ("BEN 8 XN0", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 7)] ),
>  ("BEN 9 NOT YN0", [ ( "ben0",ben0, Ival  4), ("ben1",ben1, Ival 7)] ),
>  ("BEN 8 XINF", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 0)] ),
>  ("BEN 9 NOT YINF", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 0)] ),
>  ("BEN 8 XNAN", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 1)] ),
>  ("BEN 9 NOT YNAN", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 1)] ),
>  ("BEN 8 EX1 OR EY1 2A", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 2)] ),
>  ("BEN 9 NOT EX0 AND EY0", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 2)] ),
>  ("BEN 8 EXT PREC", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 3)] ),
>  ("BEN 9 ALU DATA NOT VALID", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 3)] ),
>  ("BEN 8 NOT FADD TYPE", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 4)] ),
>  ("BEN 9 NOT MUL", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 4)] ),
>  ("BEN 8 EXR 00", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 5)] ),
>  ("BEN 9 SPARE 4", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 5)] ),
>  ("BEN 8 SPARE 5", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 6)] ),
>  ("BEN 9 NOT DEC CARRY OUT", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 6)] ),
>  ("BEN 8 SPARE 6", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 7)] ),
>  ("BEN 9 NOT ROUNDED", [ ( "ben0",ben0, Ival  5), ("ben1",ben1, Ival 7)] ),
>  ("BEN 7 ALUOP 2", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 0)] ),
>  ("BEN 8 ALUOP 3", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 0)] ),
>  ("BEN 9 NOT ALUOP 4", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 0)] ),
>  ("BEN 7 XN0", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 1)] ),
>  ("BEN 8 EY0 39", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 1)] ),
>  ("BEN 9 NOT FY0 39", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 1)] ),
>  ("BEN 7 EX1", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 2)] ),
>  ("BEN 8 EX0", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 2)] ),
>  ("BEN 9 NOT FX0", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 2)] ),
>  ("BEN 7 EY1", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 3)] ),
>  ("BEN 8 EY0 3C", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 3)] ),
>  ("BEN 9 NOT FY0 3C", [ ( "ben0",ben0, Ival  7), ("ben1",ben1, Ival 3)] ),
>  ("SIGN ADD", [ ( "sign",sign, Ival  0) ]),
>  ("SIGN MUL OR DIV", [ ( "sign",sign, Ival  1) ]),
>  ("SIGN X OP", [ ( "sign",sign, Ival  2) ]),
>  ("SIGN Y OP", [ ( "sign",sign, Ival  3) ]),
>  ("SIGN ZERO", [ ( "sign",sign, Ival  4) ]),
>  ("SIGN ONE", [ ( "sign",sign, Ival  5) ]),
>  ("SIGN XR", [ ( "sign",sign, Ival  6) ]),
>  ("SIGN RMODE", [ ( "sign",sign, Ival  7) ]),
>  ("EXMX EYL", [ ( "exmx",exmx, Ival  0) ]),
>  ("EXMX ADD", [ ( "exmx",exmx, Ival  0) ]),
>  ("EXMX EXL", [ ( "exmx",exmx, Ival  1) ]),
>  ("EXMX ZERO", [ ( "exmx",exmx, Ival  2) ]),
>  ("EXMX EXR", [ ("exmx",exmx, Ival  3) ]),
>  ("EYMX EYR", [ ( "eymx",eymx, Ival  0) ]),
>  ("EYMX PRIO ENCODE", [ ( "eymx",eymx, Ival  1) ]),
>  ("EYMX EMIT", [ ( "eymx",eymx, Ival  2),("emit",emit, Sval "$0") ]), 
>  ("EYMX EMIT SHORT", [ ( "eymx",eymx, Ival 2),("emit_right_three",emit_right_three,Sval "$0") ]),
>  ("EYMX EYL", [ ("exmx",exmx, Ival 3) ]),
>  ("EYMX ZERO", [("zero_eymx",zero_eymx, Ival 0 )]),
>  ("EALU HALF X", [("ealu",ealu,Ival 0)]),
>  ("EALU X+Y", [("ealu",ealu,Ival 1)]),
>  ("EALU PASS X", [("ealu",ealu,Ival 1),("zero_eymx",zero_eymx, Ival 0)]),
>  ("EALU PASS Y", [("ealu",ealu,Ival 1),("exmx",exmx,Ival 2)]),
>  ("EALU X-Y", [("ealu",ealu,Ival 2)]),
>  ("EALU HW", [("ealu",ealu,Ival 3),("zero_eymx",zero_eymx,Ival 0)]),
>  ("EALU HW NOT EYMX ZERO", [("ealu",ealu,Ival 3)]),
>  ("EALU ZERO", [("ealu",ealu, Ival 0),("exmx",exmx,Ival 2)]),
>  ("RF RD SEL FD RAM", [("rf_rd_sel",rf_rd_sel, Ival 0)]),
>  ("RF RD SEL HW", [("rf_rd_sel",rf_rd_sel,Ival 1)]),
>  ("RF RD SEL EMIT", [("rf_rd_sel",rf_rd_sel,Ival 2),("flipr",flipr,Ival 1)]),
>  ("RFX RD", [("rf_rd_sel",rf_rd_sel,Ival 2),("flipr",flipr,Ival 1),("rfx_rd_addr",rfx_rd_addr,Sval "$0")]),
>  ("RF RD SEL CNTR", [("rf_rd_sel",rf_rd_sel,Ival 3)]),
>  ("RF WR SEL EMIT", [("rf_wr_sel",rf_wr_sel, Ival 0),("flipw",flipw,Ival 13)]),
>  ("RFX WR", [("rf_wr_sel",rf_wr_sel, Ival 0),("rfx_wr_addr",rfx_wr_addr,Sval "$0"),("flipw",flipw,Ival 1)]),
>  ("RFX WR SEL CNTR", [("rf_wr_sel",rf_wr_sel,Ival 1)]),
>  ("FLOW SEL XY", [("flow_sel",flow_sel, Ival 0)]),
>  ("FLOW SEL XC", [("flow_sel",flow_sel,Ival 1)]),
>  ("FLOW SEL CY", [("flow_sel",flow_sel,Ival 2)]),
>  ("FLOW SEL CX", [("flow_sel",flow_sel,Ival 3)]),
>  ("LD MUL CNTR 0", [("msc_a",msc_a,Ival 1),("mul_cnt_msb",mul_cnt_msb, Ival 0),("residual",residual, Ival 0),("override_ralu_field",override_ralu_field, Ival 0)]),
>  ("LD MUL CNTR 1", [("msc_a",msc_a,Ival 1),("mul_cnt_msb",mul_cnt_msb, Ival 0),("residual",residual,Ival 1),("override_ralu_field",override_ralu_field, Ival 0)]),
>  ("LD MUL CNTR 2", [("msc_a",msc_a,Ival 1),("mul_cnt_msb",mul_cnt_msb, Ival 0),("residual",residual,Ival 2),("override_ralu_field",override_ralu_field, Ival 0)]),
>  ("LD MUL CNTR 3", [("msc_a",msc_a,Ival 1),("mul_cnt_msb",mul_cnt_msb, Ival 0),("residual",residual,Ival 3),("override_ralu_field",override_ralu_field, Ival 0)]),
>  ("RESET MUL", [("msc_a",msc_a,Ival 1)]),
>  ("SET FRC FLAG LO LAT A", [("msc_a",msc_a,Ival 2)]),
>  ("MSC A SPARE 1", [("msc_a",msc_a,Ival 3)]),
>  ("ENABLE RF WR", [("msc_a",msc_a,Ival 4)]),
>  ("CALL", [("msc_a",msc_a,Ival 6)]),
>  ("READ", [("msc_a",msc_a,Ival 11)]),
>  ("ALLOW HW SET IX", [("msc_a",msc_a,Ival 12)]),
>  ("PACK EXT FRAC", [("msc_a",msc_a,Ival 13)]),
>  ("HW RMXS", [("msc_b",msc_b, Ival 0)]),
>  ("SET SQR LAT", [("msc_b",msc_b,Ival 1)]),
>  ("SET FRC FLAG LO LAT B", [("msc_b",msc_b,Ival 2)]),
>  ("SET FRC FLAG LO LAT", [("msc_b",msc_b,Ival 2)]),
>  ("FRC FLAG HI", [("msc_b",msc_b,Ival 3)]),
>  ("FRC V BIT HI", [("msc_b",msc_b,Ival 4)]),
>  ("FRC FIRST DECODE", [("frcfirst",frcfirst,Ival 1)]),
>  ("LD BOTH PREC REG 0", [("msc_b",msc_b,Ival 6),("residual",residual,Sval "$0"),("rf_wr_sel",rf_wr_sel, Ival 0)]),
>  ("LD BOTH PREC REG 1", [("msc_b",msc_b,Ival 6),("residual",residual,Sval "$0"),("rf_wr_sel",rf_wr_sel,Ival 1)]),
>  ("LD BOTH PREC REG 2", [("msc_b",msc_b,Ival 7),("residual",residual,Sval "$0"),("rf_wr_sel",rf_wr_sel, Ival 0)]),
>  ("LD BOTH PREC REG 3", [("msc_b",msc_b,Ival 7),("residual",residual,Sval "$0"),("rf_wr_sel",rf_wr_sel,Ival 1)]),
>  ("FRC IR 02", [("msc_b",msc_b,Ival 11)]),
>  ("LD SEQ CNTR", [("msc_b",msc_b,Ival 12),("emit_right_half",emit_right_half,Sval "$0"),("eymx",eymx,Ival 2),("ealu",ealu,Ival 1),("exmx",exmx,Ival 2)]),
>  ("LD SEQ CNTR NOT EMIT", [("msc_b",msc_b,Ival 12)]),
>  ("LD RF CNTRS", [("msc_b",msc_b,Ival 13)]),
>  ("INC RD CNTRS", [("msc_b",msc_b,Ival 14)]),
>  ("LD AND INCR RF CNTRS", [("msc_b",msc_b,Ival 15)]),
>  ("SET OV", [("msc_a",msc_a,Ival 10),("msc_c",msc_c, Ival 0)]),
>  ("SET UN", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 1)]),
>  ("SET IV", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 2)]),
>  ("SET DZ", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 3)]),
>  ("SET IX", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 4)]),
>  ("CLK DENORM STICK BIT", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 5)]),
>  ("SET INTEGER OV", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 6)]),
>  ("SET INTEGER DZ", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 7)]),
>  ("SET FSUB LAT", [("flow_xtos",flow_xtos, Ival 0)]),
>  ("SET FSUBR LAT", [("enable_div_misc",enable_div_misc, Ival 0)]),
>  ("WR STATUS", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 10)]),
>  ("SET SIGN MSB LAT", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 11)]),
>  ("ASCII LAT", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 13),("maluzero",maluzero,Ival 1)]),
>  ("ASCII ASIGN C BIT", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 14)]),
>  ("CLR DENORM STICKY BIT", [("msc_a",msc_a,Ival 10),("msc_c",msc_c,Ival 15)]),
>  ("RD STATUS", [("msc_b",msc_b,Ival 9),("msc_d",msc_d, Ival 0)]),
>  ("MICRO RESET", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 1)]),
>  ("MSC D SPARE 0", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 2)]),
>  ("TRAP ALU", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 2)]),
>  ("ZERO RALU CNTRLS", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 3)]),
>  ("FRC PACK 00 HI", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 4)]),
>  ("FRC HIDDEN BITS", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 5)]),
>  ("SET MUL LAT", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 6)]),
>  ("FRC QUO BITS", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 7),("quo_bits",quo_bits,Sval"$0")]),
>  ("CLA INIT REM", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 7)]),
>  ("LD RMODE REG", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 9),("residual",residual,Sval "$0")]),
>  ("LD MICROFLAGS", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 10),("residual",residual,Sval "$0")]),
>  ("LD RALU CNTL ZERO", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 11),("residual",residual, Ival 0)]),
>  ("LD RALU CNTL HALF X", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 11),("residual",residual,Ival 1)]),
>  ("LD RALU CNTL X", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 11),("residual",residual,Ival 2)]),
>  ("LD RALU CNTL MINUS X", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 11),("residual",residual,Ival 3)]),
>  ("ASCII CLR C BIT", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 12)]),
>  ("RESET MUL LAT", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 14)]),
>  ("SET XI ZERO LAT", [("msc_b",msc_b,Ival 9),("msc_d",msc_d,Ival 15)]),
>  ("DIV CLK QB", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 14)]),
>  ("DIV CLK Q", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 13)]),
>  ("DIV CLK RS", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 11)]),
>  ("DIV CLK D", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 7)]),
>  ("DIV CLK QB Q RS", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 8)]),
>  ("DIV CLK QB RS", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 10)]),
>  ("DIV CLK RS D", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 3)]),
>  ("DIV CLK QB D", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 6)]),
>  ("DIV CLK QB Q", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 12)]),
>  ("DIV CLK Q QB", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 12)]),
>  ("DIV CLK Q RS", [("msc_a",msc_a,Ival 9),("div_clk",div_clk,Ival 9)]),
>  ("DIV LD R CLR S MZ", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 2),("malu",malu, Ival 0)]),
>  ("DIV LD D CLR Q", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 3),("maluzero",maluzero,Ival 1)]),
>  ("DIV LD R CLR S", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 2),("maluzero",maluzero,Ival 1)]),
>  ("DIV LD S CLR R", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 1),("maluzero",maluzero,Ival 1)]),
>  ("DIV Q OUT CLR D", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual, Ival 0)]),
>  ("CLEAR Q", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 3)]),
>  ("CLEAR S", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 2)]),
>  ("CLEAR R", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual,Ival 1)]),
>  ("CLEAR D", [("enable_div_misc",enable_div_misc, Ival 0),("residual",residual, Ival 0)]),
>  ("MALU ZERO", [("malu",malu, Ival 0),("shift_l_r",shift_l_r, Ival 0),("shift_ge_64",shift_ge_64,Ival 1)]),
>  ("ASCII TO INTEGER", [("malu",malu,Ival 1)]),
>  ("ASCII X+Y", [("malu",malu,Ival 2)]),
>  ("ASCII X-Y", [("malu",malu,Ival 3)]),
>  ("MALU PASS Y", [("malu",malu,Ival 5)]),
>  ("MALU Y-X", [("malu",malu,Ival 6)]),
>  ("MALU Y+X", [("malu",malu,Ival 7)]),
>  ("ALLOW FIRST DECODE", [("afd",afd, Ival 0)]),
>  ("RETURN", [("ret",ret,Ival 1)]),
>  ("FPA DONE NEXT", [("fdn",fdn,Ival 1)]),
>  ("FPA DATA VALID", [("fdv",fdv,Ival 1)]),
>  ("LAT X", [("latx",latx, Ival 0),("msc_a",msc_a,Ival 11)]),
>  ("LAT Y", [("laty",laty, Ival 0),("msc_a",msc_a,Ival 11)]),
>  ("EXL", [("exl_field",exl_field, Ival 0),("msc_a",msc_a,Ival 11)]),
>  ("EYL", [("eyl_field",eyl_field, Ival 0),("msc_a",msc_a,Ival 11)]),
>  ("EXR", [("exr_field",exr_field, Ival 0)]),
>  ("EYR", [("eyr_field",eyr_field, Ival 0)]),
>  ("SHIFT R EXP DIFF", [("shift",shift, Ival 0)]),
>  ("SHIFT L EALU", [("shift",shift,Ival 1),("override_ralu_field",override_ralu_field, Ival 0)]),
>  ("SHIFT R EALU", [("shift",shift,Ival 1),("override_ralu_field",override_ralu_field,Ival 1)]),
>  ("SHIFT L EMIT", [("shift",shift,Ival 2),("shift_l_r",shift_l_r, Ival 0),("shift_dist",shift_dist,Sval "$0")]),
>  ("SHIFT R EMIT", [("shift",shift,Ival 2),("shift_l_r",shift_l_r,Ival 1),("shift_dist",shift_dist,Sval "$0")]),
>  ("SHIFT PASS", [("shift",shift,Ival 2),("shift_l_r",shift_l_r, Ival 0),("shift_dist",shift_dist, Ival 0)]),
>  ("SHIFT L PRIO ENCODE", [("shift",shift,Ival 3)]),
>  ("SHIFT ZERO", [("shift_l_r",shift_l_r, Ival 0),("shift_ge_64",shift_ge_64,Ival 1)]),
>  ("IA DE", [("wire_or",wire_or,Ival 1),("msc_b",msc_b,Ival 10)]),
>  ("PROD OE", [("wire_or",wire_or,Ival 2),("msc_b",msc_b,Ival 10)]),
>  ("MUL OE", [("wire_or",wire_or,Ival 4),("msc_b",msc_b,Ival 10)]),
>  ("DIV OE", [("wire_or",wire_or,Ival 8),("msc_b",msc_b,Ival 10)]),
>  ("WIRE OR ZERO", [("wire_or",wire_or, Ival 0),("msc_b",msc_b,Ival 10)]),
>  ("INPUT LAT", [("input_lat_field",input_lat_field, Ival 0)]),
>  ("FLOW X TO S", [("flow_xtos",flow_xtos,Ival 1)]),
>  ("FLOW X TO T", [("flow_xtos",flow_xtos, Ival 0)]),
>  ("FLOW Y TO S", [("flow_xtos",flow_xtos, Ival 0)]),
>  ("FLOW Y TO T", [("flow_xtos",flow_xtos,Ival 1)]),
>  ("ENABLE EXCEPTIONS", [("enable_excp",enable_excp, Ival 0)]),
>  ("OVERRIDE RALU", [("override_ralu_field",override_ralu_field, Ival 0)]),
>  ("RALU ZERO", [("override_ralu_field",override_ralu_field, Ival 0),("malu",malu, Ival 0)]),
>  ("MARK", [("mark_bit",mark_bit, Ival 0)]),
>  ("HALT", [("mark_bit",mark_bit, Ival 0)]),
>  ("TWO WORDS TO ALU AFTER TRAP", [("fdn",fdn, Ival 0),("fdv",fdv,Ival 1)]),
>  ("EXCP MSG TO ALU AFTER TRAP", [("fdn",fdn,Ival 1),("fdv",fdv, Ival 0)]),
>  ("ONE WORD TO ALU AFTER TRAP", [("fdn",fdn,Ival 1),("fdv",fdv,Ival 1)]),
>  ("FREM NOP TERMINATION", [("fdn",fdn, Ival 0),("fdv",fdv,Ival 1)]),
>  ("FREM QUOTIENT DATA VALID", [("fdn",fdn,Ival 1),("fdv",fdv,Ival 1)]),
>  ("FREM REMAINDER DATA VALID", [("fdv",fdv,Ival 1)]),
>  ("EMIT RIGHT HALF", [("emit_right_half",emit_right_half,Sval "$0")]),
>  ("NAD",[("nad",nad,Sval "$0")]) ]
> 
371c428
< defaultbits = concat ( map ( assign ) defaults )
---
> defaultbits = concatMap assign  defaults 
378c435
< defaultsetbits = filter ( seceq1) defaultbits
---
> defaultsetbits = filter seceq1 defaultbits
381,384c438,441
< groupby :: Eq b => (a -> b) -> [a] -> [(b, [a])]
< groupby _ [] = []
< groupby k (x:xs) = (k x, a):groupby k b
<   where (a,b) = group2 k (k x) (x:xs);
---
> --groupby :: Eq b => (a -> b) -> [a] -> [(b, [a])]
> --groupby _ [] = []
> --groupby k (x:xs) = (k x, a):groupby k b
> --where (a,b) = group2 k (k x) (x:xs);
399c456,458
< 
---
> --
> --
> --
401,402c460,463
< sbitxerror (a,b,c,d,e) = "bit " ++ show(a) ++ " set by macro " ++ c ++ " field " ++ d ++ " to val = " ++ show( b) ++ "; "
< 
---
> sbitxerror (a,b,c,d,e) = "bit " ++ show a ++ " set by macro " ++ c ++ " field " ++ d ++ " to val = " ++ show( b) ++ "; "
> --
> --
> --
404,406c465,468
< abitxerror [] = []
< abitxerror (x:xs) = sbitxerror x  ++ abitxerror xs
< 
---
> abitxerror xs = foldr ( (++) . sbitxerror) [] xs
> --
> --
> --
409c471
< bitxerror (x:xs) = (abitxerror x ) ++ "end"  ++ (bitxerror xs)
---
> bitxerror (x:xs) = abitxerror x  ++ "end"  ++ bitxerror xs
420a483
> --
423,424c486,487
< filterValsdiff (x:xs) | (( valCount x ) > 1) = x : filterValsdiff xs
<                       | (( valCount x) == 1) = filterValsdiff xs
---
> filterValsdiff (x:xs) | valCount x  > 1 = x : filterValsdiff xs
>                       | valCount x == 1 = filterValsdiff xs
429,431c492,543
< filterLen n (x:xs) | ((length x ) > n) = x : filterLen n  xs
<                    | ((length x ) == n) = filterLen n xs
<     
---
> filterLen n (x:xs) | length x  > n = x : filterLen n  xs
>                    | length x  == n = filterLen n xs
> --
> --  dis assemble an Integer to its bitfields
> --
> disassembleFields::Integer->[(String,[Int],Integer)]
> disassembleFields x = map ( evalFields x ) allfields
> --
> --  disassemble a hex string 
> --
> disassembleHex::String->[(String,[Int],Integer)]
> disassembleHex str = disassembleFields ( read ("0x" ++ str))
> --
> --        produce disassembly output for a given hex string
> --
> fmtDisassembly::String->String
> fmtDisassembly str = "\n" ++ fmtDisassemblyFields (disassembleHex str) ++ "\n\n" ++ concatMap (fmtDisassemblyMacros inval) (reverse ( tail (reverse (filterMacroDefs inval)))) ++ fmtDisassemblyMacrosNC inval (last (filterMacroDefs inval)) ++ ";" ++ "\n"
>             where   inval = read ("0x" ++ str)
> --
> --
> --
> fmtDisassemblyInlines::(String,String)->String
> fmtDisassemblyInlines (addr,hexval) = "\n" ++ addr ++ " " ++ hexval ++ "\n" ++ fmtDisassembly (reverse (map (reverseOneHex) hexval))
> --
> --
> fmtDisassemblyAlllines::[(String,String)]->String
> fmtDisassemblyAlllines xs = concatMap fmtDisassemblyInlines xs
> --
> --
> fmtDisassemblyInput::[String]->String
> fmtDisassemblyInput xs = fmtDisassemblyAlllines ( map splitLineIn xs)
> --
> --
> splitLineIn::String->(String,String)
> splitLineIn str = (dropWhile ( == '@') a, trim b )
>                  where (a,b) = (head (words str), head (tail  (words str)))
> --
> --
> --
> fmtDisassemblyFields::[(String,[Int],Integer)]->String
> fmtDisassemblyFields xs | length xs == 1 = fmtDisassemblyFieldNC (head xs) ++ ";"
> fmtDisassemblyFields xs = foldr ( (++) . fmtDisassemblyField) " " (reverse ( tail (reverse xs))) ++ fmtDisassemblyFieldNC (last xs) ++ ";"
> --
> --
> --
> fmtDisassemblyField::(String,[Int],Integer)->String
> fmtDisassemblyField (name,bits,value) = name ++ "=" ++ show value ++ ", "
> --
> --
> --
> fmtDisassemblyFieldNC::(String,[Int],Integer)->String
> fmtDisassemblyFieldNC (name,bits,value) = name ++ "=" ++ show value 
432a545,557
> --
> --
> --
> evalFields::Integer->(String,[Int])->(String,[Int],Integer)
> evalFields x (a, b) = ( a, b, evalField x b)
> --
> --
> --
> getAField::Integer->(String,[Int],Val)->(String,[Int],Integer)
> getAField  b (fname,flst,_) = (fname,flst, evalField b flst)
> --
> --
> --
435c560,562
< 
---
> --
> --
> --
437c564
< rangetostr (a,b,c) = (a, b, c, show(a) )
---
> rangetostr (a,b,c) = (a, b, c, show a )
445,446c572,573
< errorstrfrombitlist s = bitxerror (  filterValsdiff (filterLen 1  ( groupBy (fsteq) (expandbitlist s )  ) ))
< 
---
> errorstrfrombitlist s = bitxerror (  filterValsdiff (filterLen 1  ( groupBy fsteq  (expandbitlist s )  ) ))
> --
447a575
> --
450,453c578,582
< 
< hexfromints::[Int] -> [Char]
< hexfromints [] = []
< hexfromints (x:xs) = [hexfromint x] ++ hexfromints xs 
---
> --
> --
> --
> hexfromints::[Int] -> String
> hexfromints xs = map hexfromint xs 
455a585
> --
457,458c587,588
< comparefst (a,c) (b,d) | ( ((3 * a) + c) <  ((3* b) + d ) ) = LT
<                        | ( ((3 * a) + c) ==  ((3* b) + d ) ) = EQ
---
> comparefst (a,c) (b,d) | ((3 * a) + c) <  ((3* b) + d ) = LT
>                        | ((3 * a) + c) ==  ((3* b) + d )  = EQ
462,463c592,595
< frstdiv4eq0 (a,_) (b,_)= ( div a 4 ) == (div b 4)
< 
---
> frstdiv4eq0 (a,_) (b,_)= div a 4  ==  div b 4
> --
> --
> --
467c599,601
< 
---
> --
> --
> --
469,470c603
< setbits [] = 0
< setbits (x:xs) = (setbit x ) + (setbits xs)
---
> setbits xs = foldr ((+) . setbit) 0 xs
474,475c607,608
< blankbits x = zip (  [a | a <-[0..(biggest x)], (mod a 4) == 0 ] ) ( replicate (biggest x) (2) )
<    where biggest n = ( maximum ( map ( fst) n ) )
---
> blankbits x = zip (  [a | a <-[0..(biggest x)], mod a 4 == 0 ] ) ( replicate (biggest x) 2 )
>    where biggest n = maximum ( map ( fst) n ) 
478c611,617
< testto x  =   groupBy ( frstdiv4eq0) x
---
> --
> fstSame::(Int,Int)->(Int,Int)->Bool
> fstSame  (a,b) (c,d) = (a==c)
> --
> --
> --
> testto  =   groupBy frstdiv4eq0 
480a620,626
> --
> --    assumes sortBy will put all the bits from the field bit assignments
> --           before the default bit assigns
> --           the nubBy will pick the field bit assignment if there is no
> --              default or not, and will pick up the default if there is no
> --              field assignment
> --
482,483c628,629
< combine x  = nub ( sortBy ( comparefst) ( x ++ defaultsetbits ) ) 
< 
---
> combine x  = nubBy (fstSame)  ( sortBy ( comparefst) ( x ++ defaultsetbits ) ) 
> --
485a632
> --
499c646
< evalmac (x:xs) z  =  (assign  x ) ++   ( evalmac xs  z )
---
> evalmac (x:xs) z  =  assign  x  ++   ( evalmac xs  z )
500a648
> -- given an integer, get the list of bits, lowest to highest
504,506c652,656
< bitsfromints n = (mod n 2 ) : bitsfromints ( div n 2 )
< 
< bitsfromintsrev::Int -> [Int]
---
> bitsfromints n = mod n 2  : bitsfromints ( div n 2 )
> --
> -- given an integer, get  the list of bits, highest to lowest
> --
> bitsfromintsrev::Integer -> [Int]
508c658,760
< bitsfromintsrev n = ( bitsfromintsrev ( div n 2)) ++ [(mod n 2)]
---
> bitsfromintsrev n = ( bitsfromintsrev ( div n 2)) ++ [fromInteger (mod n 2)]
> -- 
> -- given a list of [0 or 1] give the integer corresponding to that list of bits
> --
> intfrombits::[Int]->Integer
> intfrombits x =  sum (map (multPair) (zip x ( map (2^) [0..])) )
> --
> --
> multPair::(Int,Integer)->Integer
> multPair (x,y) = (toInteger x)*y
> --
> --    get the nth bit of an Integer, return as 0 or 1
> --
> getABit::Integer->Int->Int
> getABit val bitpos | (bitpos < 0) = error "bad bitpos"
> getABit val bitpos | ( andInteger val (2^bitpos) == 2^bitpos) = 1
> getABit val bitpos | otherwise = 0
> --
> --given an Integer,and a list of bit positions, get a list of the
> --   corresponding bits
> --
> getBitList::Integer->[Int]->[Int]
> getBitList  val xs = map (getABit val ) xs 
> --
> -- given an Integer and a list of bit positions, get the Integer value of thos
> --     corresponding to those bits
> --
> getBitListVal::Integer->[Int]->Integer
> getBitListVal val ls = intfrombits ( reverse (getBitList val ls))
> --
> -- Determine if a list of booleans are all true
> --
> allTrue::[Bool]->Bool
> allTrue = foldr  (&&) True 
> --
> --  evaluate a macro based on the the given bits (inval integer)
> --     to see if all the field values match 
> --
> evalMacro::Integer->Macro->Bool
> evalMacro inval (mname,mlst)  = allTrue ( map ( fieldTrue  inval) mlst )
> --
> --   determine if the field values corresponds to the bits in inval
> --        specified the by the field bits
> --
> fieldTrue::Integer->(String,[Int], Val)->Bool
> fieldTrue inval (str, a, Sval b) = True
> fieldTrue  inval (str, a,Ival b) = (evalField inval  a) == b
> --
> --   extract the bitfield of a field and convert it to integer
> --
> evalField::Integer->[Int]->Integer
> evalField inval fls =  getBitListVal inval fls
> --
> --
> -- find Macros that work
> --
> filterMacro inval  = filter (evalMacro inval) 
> --
> --
> filterMacroDefs::Integer->[Macro]
> filterMacroDefs inval = filterMacro inval macrodefs
> --
> --
> --
> fmtDisassemblyMacros::Integer->(String,[(String,[Int],Val)])->String
> fmtDisassemblyMacros b (macname,flst) = "  " ++ macname  ++  (fmtMDisField b flst) ++ "," ++ "\n"
> --
> --
> fmtDisassemblyMacrosNC::Integer->(String,[(String,[Int],Val)])->String
> fmtDisassemblyMacrosNC b (macname,flst) = "  " ++ macname  ++  (fmtMDisField b flst) 
> --
> --
> --
> fmtMDisField::Integer->[(String,[Int],Val)]->String
> fmtMDisField b flst | length valflst > 0 =  "(" ++ (showSvalFields  b valflst)  ++ ")"
>                       where
>                         valflst = filter (hasSvalField) flst 
> fmtMDisField b flst  = " "
>                  
> --
> --
> --
> hasSvalField::(String,[Int],Val)->Bool
> hasSvalField (fname,fblst,Sval v) = True
> hasSvalField (fname,fblst,Ival v) = False
> --
> --
> --
> showSvalFields::Integer->[(String,[Int],Val)]->String
> showSvalFields b [] = ""
> showSvalFields b xs = foldr ((++) . showSvalField b) "" (reverse ( tail (reverse xs))) ++ showSvalFieldNC  b (last xs)
> --
> --
> --
> showSvalField::Integer->(String,[Int],Val)->String
> showSvalField b (fname,fblst,Sval v) = fname ++ "=" ++ show (evalField b fblst) ++ ","
> showSvalField b (fname,fblst,Ival v) = ""
> --
> --
> --
> showSvalFieldNC::Integer->(String,[Int],Val)->String
> showSvalFieldNC b (fname,fblst,Sval v) = fname ++ "=" ++ show (evalField b fblst) 
> showSvalFieldNC b (fname,fblst,Ival v) = ""
509a762,769
> --
> --
> --
> bitzeropad::[Int]->Integer->[Int]
> bitzeropad xs v | length xs > length ( bitsfromintsrev v) = (replicate ( length xs - length ( bitsfromintsrev v)) 0 ) ++ (bitsfromintsrev v)
> bitzeropad xs v | length xs == length (bitsfromintsrev v) = bitsfromintsrev v
> bitzeropad xs v | otherwise = error ("Integer does not fit in field " ++ " list = " ++ show xs ++ " integer = " ++ show v )
> --
510a771
> --
512c773
< assign (a,Ival b) = zip a (bitsfromintsrev b )
---
> assign (a,Ival b) = zip a ( bitzeropad a b)
517,520c778,781
< assignParam:: ([Int],Val)-> Paramtable ->  [(Int,Int)]
< assignParam (a, Ival b) _  =  zip a ( bitsfromintsrev b )
< assignParam (a, Sval b) s  = case (lookup (trim b)  s  ) of 
<                    Just y ->   zip a ( bitsfromintsrev y )
---
> assignParam:: ([Int],Val)-> Paramtable -> [(Int,Int)]
> assignParam ( a, Ival b) _  =   zip a ( bitzeropad a b )
> assignParam ( a, Sval b) s  = case (lookup (trim b)  s  ) of 
>                    Just y ->   zip a ( bitzeropad a y )
530c791,793
< 
---
> --
> --
> --
534c797,799
< 
---
> --
> --
> --
538c803,805
< 
---
> --
> --
> --
544a812,814
> --
> --
> --
551c821,823
< 
---
> --
> --
> --
555c827
< 
---
> --
561c833,835
< 
---
> --
> --
> --
564,567c838,841
< 
< expandparm::[String]->[(String,[String])]
< expandparm [] = []
< expandparm (x:xs) = expandoneparm x :  expandparm xs 
---
> --
> --
> --
> expandparm  = map expandoneparm 
579,580c853,854
< getlabels s | length ( fst(break (== ':') s  ))  == (length s) = [ ( fst( break ( == ':') s), 0) ]
<              |  otherwise = ( fst(break ( == ':') s) , 1 ) : getlabels ( drop 1( snd(break ( == ':' ) s ) ))
---
> getlabels s | length ( fst( break  (== ':') s  ))  == (length s) = [ ( fst( break ( == ':') s), 0) ]
>              |  otherwise = ( fst( break  ( == ':') s) , 1 ) : getlabels ( drop 1( snd( break  ( == ':' ) s ) ))
583c857
< sndeq1 (x,y) = (y==1)
---
> sndeq1 (x,y) = y==1
593c867,868
< 
---
> --
> --
596,600c871,878
< 
< removeSpace::String->String
< removeSpace x = dropWhile (' '==) x
< 
< doMacrolu:: String -> Maybe [([Int],Val)]
---
> --
> --
> --
> removeSpace  = dropWhile (' '==) 
> --
> --   lookup macros
> --
> doMacrolu:: String -> Maybe [(String,[Int],Val)]
602,604c880,883
< 
< doMac::String->[([Int],Val)]
< doMac x = case (doMacrolu x) of
---
> --
> --
> doMac::String->[(String,[Int],Val)]
> doMac x = case doMacrolu x of
607,609c886,890
< 
< addname::String->([Int],Val)->([Int],Val,String)
< addname s (a,b) = (a,b,s)
---
> --
> --
> --
> addname::String->(String,[Int],Val)->(String,[Int],Val,String)
> addname s (str,a,b) = (str,a,b,s)
613c894
< doMacstr::String->[([Int],Val,String)]
---
> doMacstr::String->[(String,[Int],Val,String)]
617c898
< 
---
> --
619a901
> --
621c903
< ptablefrommacroinst st (a,b)   = ((removeSpace a), parmtablefromlist b st 0 )
---
> ptablefrommacroinst st (a,b)   = ( removeSpace a, parmtablefromlist b st 0 )
633,635c915,919
< 			| op == '/'  = div x y
< 			| op == '%'  = mod x y
<       
---
>             | op == '/'  = div x y
>             | op == '%'  = mod x y
> --
> --
> --
638c922,924
< 
---
> --
> --
> --
641,645c927,933
< 
< nextval:: String->Int
< nextval s | ( (length s) == 0 ) = 0
<           | ((head s) == '#' )= intfromStr s
<           | (elem ( head s) ['0','1','2','3','4','5','6','7','8','9'] ) = intfromStr s
---
> --
> --
> --
> nextval:: String->Integer
> nextval s | null s  = 0
>           | head s == '#' = integerfromStr s
>           | (elem ( head s) ['0','1','2','3','4','5','6','7','8','9'] ) = integerfromStr s
648,649c936,937
< doopcr::(Int,String)->Int
< doopcr (x,s) | ( ( length s ) == 0 ) =  x
---
> doopcr::(Integer,String)->Integer
> doopcr (x,s) | null s =  x
652,660c940,948
< doopc::(Int,String) -> (Int, String)
< doopc (x,s) | ((length s ) ==0 ) = (x,[])
<              | ((head s)  == '+')  = ( x + nextval ( nextstr ( drop 1 s)) , reststr (drop 1 s) )
<              | ((head s) == '-')  = ( x - nextval ( nextstr (drop 1 s)), reststr ( drop 1 s) )
< 	     | ((head s ) == '*')  = ( x * nextval ( nextstr (drop 1 s)), reststr ( drop 1 s) )
< 	     | ((head s) == '/')  = ( div x (nextval ( nextstr (drop 1 s))), reststr( drop 1 s))
< 	     | ((head s) == '%')  = ( mod x ( nextval ( nextstr (drop 1 s))), reststr( drop 1 s))
<              | ((head s) == ':')  = ( x -  ( mod x ( nextval ( nextstr (drop 1 s)))), reststr( drop 1 s))
<              | ( length s == 0 ) = (x,[])
---
> doopc::(Integer,String) -> (Integer, String)
> doopc (x,s) |  null s = (x,[])
>              | head s  == '+'  = ( x + nextval ( nextstr ( drop 1 s)) , reststr (drop 1 s) )
>              | head s == '-' = ( x - nextval ( nextstr (drop 1 s)), reststr ( drop 1 s) )
>              | head s == '*'  = ( x * nextval ( nextstr (drop 1 s)), reststr ( drop 1 s) )
>              | head s == '/'  = ( div x (nextval ( nextstr (drop 1 s))), reststr( drop 1 s))
>              | head s == '%'  = ( mod x ( nextval ( nextstr (drop 1 s))), reststr( drop 1 s))
>              | head s == ':'  = ( x -  ( mod x ( nextval ( nextstr (drop 1 s)))), reststr( drop 1 s))
>              | null s = (x,[])
666c954
< breakl:: [Char]->String->(String,String)
---
> breakl::String->String->(String,String)
668c956,958
< 
---
> --
> --
> --
673c963,972
< 
---
> --
> --
> --
> topowI::( Char,Integer)-> Integer
> topowI (a,b) = case elemIndex a "0123456789" of 
>                 Just y -> (toInteger y) * b 
>                 Nothing -> 0
> --
> --
> --
675c974
< topowsixteen (a,b) = case (elemIndex a "0123456789ABCDEF" ) of 
---
> topowsixteen (a,b) = case elemIndex a "0123456789ABCDEF"  of 
678c977,986
< 
---
> --
> --
> --
> topowsixteenI::( Char,Integer)-> Integer
> topowsixteenI (a,b) = case elemIndex a "0123456789ABCDEF"  of 
>                 Just y -> (toInteger y) * b 
>                 Nothing -> 0
> --
> --
> --
680c988
< topoweight (a,b) = case (elemIndex a "01234567" ) of 
---
> topoweight (a,b) = case elemIndex a "01234567"  of 
683c991,1000
< 
---
> --
> --
> --
> topoweightI::( Char,Integer)-> Integer
> topoweightI (a,b) = case elemIndex a "01234567"  of 
>                 Just y -> (toInteger y) * b 
>                 Nothing -> 0
> --
> --
> --
687a1005,1011
> --
> --
> --
> topowtwoI::( Char,Integer)-> Integer
> topowtwoI (a,b) = case (elemIndex a "01" ) of 
>                 Just y -> (toInteger y) * b 
>                 Nothing -> 0
689c1013
< lookupSym::String->Symboltable->Int
---
> lookupSym::String->Symboltable->Integer
691c1015
<                   Just x -> x
---
>                   Just x -> toInteger x
698,709c1022,1042
< intfromStr x | ( head x == '#') = foldr (+) 0 (map (topowsixteen)  ( zip (reverse ( drop 1 x)  ) ( map (16 ^ ) [0..] )) )
<              | ( head x == 'B') = foldr (+) 0 (map (topowtwo)  ( zip (reverse (drop 1 x  )) ( map (2 ^ ) [0..] )) )
<              | ( head x == 'O') = foldr (+) 0 (map (topoweight)  ( zip (reverse (drop 1 x  )) ( map (8 ^ ) [0..] )) )
<              | otherwise = foldr (+) 0 (map (topow)  ( zip (reverse x  ) ( map (10 ^ ) [0..] )) )
< 
< 
< parseExp::String->Symboltable->Int
< parseExp s tab  | ( (length s) == 0 ) = 0
<                 | ((head s) == '#' )= intfromStr s
<                 | (elem ( head s) ['0','1','2','3','4','5','6','7','8','9'] ) = intfromStr s
<                | ( length ( take 1 ( reststr  s ))==0) = (lookupSym ( nextstr  s )   tab )
<                | otherwise  =  doopcr ( lookupSym ( nextstr s )  tab ,  reststr s ) 
---
> intfromStr x | ( head x == '#') = sum (map (topowsixteen)  ( zip (reverse ( drop 1 x)  ) ( map (16 ^ ) [0..] )) )
>              | ( head x == 'B') = sum (map (topowtwo)  ( zip (reverse (drop 1 x  )) ( map (2 ^ ) [0..] )) )
>              | ( head x == 'O') = sum (map (topoweight)  ( zip (reverse (drop 1 x  )) ( map (8 ^ ) [0..] )) )
>              | otherwise = sum  (map (topow)  ( zip (reverse x  ) ( map (10 ^ ) [0..] )) )
> --
> --
> --
> integerfromStr::String->Integer
> integerfromStr x | ( head x == '#') = sum (map (topowsixteenI)  ( zip (reverse ( drop 1 x)  ) ( map (16 ^ ) [0..] )) )
>              | ( head x == 'B') = sum (map (topowtwoI) ( zip (reverse (drop 1 x  )) ( map (2 ^ ) [0..] )) )
>              | ( head x == 'O') = sum (map (topoweightI)  ( zip (reverse (drop 1 x  )) ( map (8 ^ ) [0..] )) )
>              | otherwise = sum (map (topowI)  ( zip (reverse x  ) ( map (10 ^ ) [0..] )) )
> --
> --
> --
> parseExp::String->Symboltable->Integer
> parseExp s tab  | null s = 0
>                 | head s == '#' = integerfromStr s
>                 | elem ( head s) ['0','1','2','3','4','5','6','7','8','9']  = integerfromStr s
>                | length ( take 1 ( reststr  s ))==0  = lookupSym ( nextstr  s )   tab 
>                | otherwise  = toInteger ( doopcr ( lookupSym ( nextstr s )  tab ,  reststr s ) )
721,722c1054,1057
< mksym x =   concat(  map (symfromstate) ( setlocations ( parseallstate x)  0 ))
< 
---
> mksym x =   concatMap symfromstate ( setlocations ( parseallstate x)  0 )
> --
> --
> --
744c1079,1081
< 
---
> --
> --
> --
755,757c1092,1096
< setlocations (x:xs) m | ((forst x ) > -1 )=  [(setloc x  m )] ++ setlocations xs m 
<                       | otherwise =  [(setloc x  m )] ++ setlocations xs (max ( forst ( head xs) ) (m+1) )
< 
---
> setlocations (x:xs) m | ((forst x ) > -1 )=  (setloc x  m ) :  setlocations xs m 
>                       | otherwise =  (setloc x m) :  setlocations xs (max ( forst ( head xs) ) (m+1) )
> --
> --
> --
797a1137,1143
> stripFieldNames::[(String,[Int],Val)]->[([Int],Val)]
> stripFieldNames (x:xs) = stripFieldName x : stripFieldNames xs
> --
> --
> --
> stripFieldName::(String,[Int],Val)->([Int],Val)
> stripFieldName (fname,lst,v) = (lst,v)
804,805c1150,1151
< assignlistfromparmeval (x:xs) = case ( lookup (trim (fst x))  macrodefs ) of 
<                                 Just y  -> [( y, (fst x),  (snd x) , "")] ++ assignlistfromparmeval xs                           
---
> assignlistfromparmeval (x:xs) = case  lookup (trim (fst x))  macrodefs of 
>                                 Just y  -> ( map (stripFieldName) y, (fst x),  (snd x) , "") : assignlistfromparmeval xs                           
811c1157,1158
< --given Parmtable, set of bits to be assigned a value form ( [bit_assignment_tuples],macroname,
---
> --given Parmtable, set of bits to be assigned a value from
> --           ( [bit_assignment_tuples],macroname,
812a1160,1161
> --              macroname->parmtable->errorstr->assignment
> --
813a1163
> --abitfromassign s pt d x  = trace ("abit from assign = " ++ s ) (assignParam x pt, s, show ( fst ( x) ), d)
825,827d1174
< 
< 
< 
833,834c1180,1183
< tobitlistfromassignlist x = concat ( map ( tobitlistfromassign) x )
< 
---
> tobitlistfromassignlist x = concatMap  tobitlistfromassign x 
> --
> --
> --
837c1186,1188
< 
---
> --
> --
> --
840,844c1191,1197
< 
< expandbitlist::[([(Int,Int)],String,String,String)]->[(Int,Int,String,String,String)]
< expandbitlist [] = []
< expandbitlist (x:xs) = bitsfromassign x ++ expandbitlist xs
< 
---
> --
> --
> --
> expandbitlist = foldr ((++) . bitsfromassign) [] 
> --
> --
> --
846c1199,1201
< 
---
> --
> --
> --
848,850c1203,1206
< expandjustbitlist [] = []
< expandjustbitlist (x:xs) =  (first x ) ++ expandjustbitlist xs
< 
---
> expandjustbitlist xs = foldr ((++) . first ) [] xs
> --
> --
> --
852,853c1208,1210
< 
< 
---
> --
> --
> --
857,858c1214,1216
<              
< 
---
> --
> --
> --
860,861c1218
< erroraccum [] = []
< erroraccum (x:xs) =  anerror x  ++ erroraccum xs
---
> erroraccum xs =  foldr ((++) . anerror ) [] xs
867c1224
< frombitslisttoanswer x n  | ( length ( errorstrfrombitlist x ) > 0 ) = (n, (errorstrfrombitlist x ) ++ (erroraccum x), "0")
---
> frombitslisttoanswer x n  | not ( null ( errorstrfrombitlist x ) )  = (n, (errorstrfrombitlist x ) ++ (erroraccum x), "0")
907c1264,1266
< 
---
> --
> --
> --
918,919c1277,1278
<   | x >= 0 && x <= 9      = chr (x + (ord '0'))
<   | x >= 10 && x <= 15    = chr (x - 10 + (ord 'a'))
---
>   | x >= 0 && x <= 9      = chr (x + ord '0')
>   | x >= 10 && x <= 15    = chr (x - 10 + ord 'a' )
921c1280,1282
< 
---
> --
> --  take an integer and make into a hex string
> --
925c1286,1288
< 
---
> --
> --
> --
932c1295,1297
<                  
---
> --
> --  Add , newline to a string
> --
935c1300,1302
< 
---
> --
> --
> --
937c1304
< tolines x = concat ( map (addlf ) ( take ((length ( lbc x ))-1) (lbc x ))) ++ last ( lbc x)
---
> tolines x = concatMap addlf  ( take ((length ( lbc x ))-1) (lbc x )) ++ last ( lbc x)
943c1310
< ansformat a b | (length b < 1) = []
---
> ansformat a b | length b < 1 = []
951,952c1318,1320
< 
< 
---
> --
> --
> --
954c1322,1332
< fmtsym (a,b) = "Symbol: " ++ trim ( a ) ++ " .." ++ "0x" ++ frominttohex b
---
> fmtsym (a,b) = "Symbol: " ++ trim a ++ " .." ++ show  b
> --
> --
> --
> reverseOneHex::Char->Char
> reverseOneHex c = ['0','8','4','C','2','A','6','E','1','9','5','D','3','B','7','F']!!(read ("0x" ++ [c] ))
> 
> --
> -- Main routine for meta assembler
> --        reads in a file of statements as first argument
> --        prints to standard out
958,959c1336,1337
<          (putStr  ( unlines  (  map  (formatstatement) ( dostatements   ( concat ( lines f ) ))))) ; 
<            (writeFile "out.sym" ( unlines ( (map (fmtsym) (fst ( tosymtablefromraw f ) ))))); }
---
>            (putStr  ( unlines  (  map  (formatstatement) ( dostatements   ( concat ( lines f ) ))))) ; 
>            (putStr ( unlines ( (map (fmtsym) (fst ( tosymtablefromraw f ) ))))); }
